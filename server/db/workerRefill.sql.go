// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: workerRefill.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getOldestMatchHistories = `-- name: GetOldestMatchHistories :many
SELECT
    puuid,
    background_update_timestamp
FROM tft_summoner
ORDER BY background_update_timestamp ASC NULLS FIRST
LIMIT $1
`

type GetOldestMatchHistoriesRow struct {
	Puuid                     string           `json:"puuid"`
	BackgroundUpdateTimestamp pgtype.Timestamp `json:"backgroundUpdateTimestamp"`
}

func (q *Queries) GetOldestMatchHistories(ctx context.Context, limit int32) ([]GetOldestMatchHistoriesRow, error) {
	rows, err := q.db.Query(ctx, getOldestMatchHistories, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOldestMatchHistoriesRow
	for rows.Next() {
		var i GetOldestMatchHistoriesRow
		if err := rows.Scan(&i.Puuid, &i.BackgroundUpdateTimestamp); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPuuidsWithNullAccountData = `-- name: GetPuuidsWithNullAccountData :many
SELECT
    puuid
FROM tft_summoner
WHERE (name IS NULL OR tag IS NULL) AND NOT skip_account
LIMIT $1
`

func (q *Queries) GetPuuidsWithNullAccountData(ctx context.Context, limit int32) ([]string, error) {
	rows, err := q.db.Query(ctx, getPuuidsWithNullAccountData, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var puuid string
		if err := rows.Scan(&puuid); err != nil {
			return nil, err
		}
		items = append(items, puuid)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPuuidsWithNullSummonerData = `-- name: GetPuuidsWithNullSummonerData :many
SELECT
    puuid
FROM tft_summoner
WHERE summoner_id IS NULL
LIMIT $1
`

func (q *Queries) GetPuuidsWithNullSummonerData(ctx context.Context, limit int32) ([]string, error) {
	rows, err := q.db.Query(ctx, getPuuidsWithNullSummonerData, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var puuid string
		if err := rows.Scan(&puuid); err != nil {
			return nil, err
		}
		items = append(items, puuid)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setBackgroundUpdateTimestamp = `-- name: SetBackgroundUpdateTimestamp :exec
UPDATE tft_summoner
SET background_update_timestamp = $2::TIMESTAMP
WHERE puuid = $1
`

type SetBackgroundUpdateTimestampParams struct {
	Puuid                     string           `json:"puuid"`
	BackgroundUpdateTimestamp pgtype.Timestamp `json:"backgroundUpdateTimestamp"`
}

func (q *Queries) SetBackgroundUpdateTimestamp(ctx context.Context, arg SetBackgroundUpdateTimestampParams) error {
	_, err := q.db.Exec(ctx, setBackgroundUpdateTimestamp, arg.Puuid, arg.BackgroundUpdateTimestamp)
	return err
}

const setSkipAccountFlag = `-- name: SetSkipAccountFlag :exec
UPDATE tft_summoner
SET skip_account = $2
WHERE puuid = $1
`

type SetSkipAccountFlagParams struct {
	Puuid       string `json:"puuid"`
	SkipAccount bool   `json:"skipAccount"`
}

func (q *Queries) SetSkipAccountFlag(ctx context.Context, arg SetSkipAccountFlagParams) error {
	_, err := q.db.Exec(ctx, setSkipAccountFlag, arg.Puuid, arg.SkipAccount)
	return err
}
